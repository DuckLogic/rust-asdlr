// File automatically generated by rust/__main__.py.

use derivative::Derivative;
use astlib::Span;
use astlib::builtins::{Ident, Constant};
use serde::Serialize;

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub enum Decl<'a> {
    Module {
        /// Shared attribute
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        name: Ident,
        imports: &'a [Import],
        decls: &'a [TypeDecl],

    },
    PrimitiveModule {
        /// Shared attribute
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        name: Ident,
        exports: &'a [Ident],

    },
    View {
        /// Shared attribute
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        name: Ident,
        decls: &'a [ViewDecl],

    },
}
impl<'a> Decl<'a> {
    /// Shared attribute
    pub fn name(&self) -> &Ident {
        match *self {
            Decl::Module { ref name, .. } |
            Decl::PrimitiveModule { ref name, .. } |
            Decl::View { ref name, .. } => name,
        }
    }
}
#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub enum Import<'a> {
    Imports {
        module: Ident,
        alias: Option<Ident>,

    },
}
#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub struct Path<'a> {
    pub qualifier: Option<Ident>,
    pub base: Ident,
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, Serialize)]
pub enum Tycon<'a> {
    Option=1,
    Sequence=2,
    Shared=3,
}

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub struct Field<'a> {
    pub typ: &'a Path<'a>,
    pub label_opt: Option<Ident>,
    pub tycon_opt: Option<Tycon>,
}

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub struct Constructor<'a> {
    pub name: Ident,
    pub fs: &'a [Field],
}

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub enum TypeDecl<'a> {
    SumType {
        /// Shared attribute
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        name: Ident,
        attribs: &'a [Field],
        c: &'a Constructor<'a>,
        cs: &'a [Constructor],

    },
    ProductType {
        /// Shared attribute
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        name: Ident,
        f: &'a Field<'a>,
        fs: &'a [Field],

    },
}
impl<'a> TypeDecl<'a> {
    /// Shared attribute
    pub fn name(&self) -> &Ident {
        match *self {
            TypeDecl::SumType { ref name, .. } |
            TypeDecl::ProductType { ref name, .. } => name,
        }
    }
}
#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub struct ViewDecl<'a> {
    pub entity: &'a [Ident],
    pub prop: String,
    pub value: String,
}


