// File automatically generated by rust/__main__.py.

use derivative::Derivative;
use astlib::Span;
use astlib::builtins::{Ident, Constant};
use serde::Serialize;

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub enum Mod<'a> {
    Module {
        body: &'a [Stmt],
        type_ignores: &'a [TypeIgnore],

    },
    Interactive {
        body: &'a [Stmt],

    },
    Expression {
        body: &'a Expr<'a>,

    },
    FunctionType {
        argtypes: &'a [Expr],
        returns: &'a Expr<'a>,

    },
}
#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub enum Stmt<'a> {
    FunctionDef {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        name: Ident,
        args: &'a Arguments<'a>,
        body: &'a [Stmt],
        decorator_list: &'a [Expr],
        returns: Option<&'a Expr<'a>>,
        type_comment: Option<String>,

    },
    AsyncFunctionDef {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        name: Ident,
        args: &'a Arguments<'a>,
        body: &'a [Stmt],
        decorator_list: &'a [Expr],
        returns: Option<&'a Expr<'a>>,
        type_comment: Option<String>,

    },
    ClassDef {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        name: Ident,
        bases: &'a [Expr],
        keywords: &'a [Keyword],
        body: &'a [Stmt],
        decorator_list: &'a [Expr],

    },
    Return {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        value: Option<&'a Expr<'a>>,

    },
    Delete {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        targets: &'a [Expr],

    },
    Assign {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        targets: &'a [Expr],
        value: &'a Expr<'a>,
        type_comment: Option<String>,

    },
    AugAssign {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        target: &'a Expr<'a>,
        op: Operator,
        value: &'a Expr<'a>,

    },
    AnnAssign {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        target: &'a Expr<'a>,
        annotation: &'a Expr<'a>,
        value: Option<&'a Expr<'a>>,
        simple: i32,

    },
    For {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        target: &'a Expr<'a>,
        iter: &'a Expr<'a>,
        body: &'a [Stmt],
        orelse: &'a [Stmt],
        type_comment: Option<String>,

    },
    AsyncFor {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        target: &'a Expr<'a>,
        iter: &'a Expr<'a>,
        body: &'a [Stmt],
        orelse: &'a [Stmt],
        type_comment: Option<String>,

    },
    While {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        test: &'a Expr<'a>,
        body: &'a [Stmt],
        orelse: &'a [Stmt],

    },
    If {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        test: &'a Expr<'a>,
        body: &'a [Stmt],
        orelse: &'a [Stmt],

    },
    With {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        items: &'a [Withitem],
        body: &'a [Stmt],
        type_comment: Option<String>,

    },
    AsyncWith {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        items: &'a [Withitem],
        body: &'a [Stmt],
        type_comment: Option<String>,

    },
    Match {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        subject: &'a Expr<'a>,
        cases: &'a [MatchCase],

    },
    Raise {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        exc: Option<&'a Expr<'a>>,
        cause: Option<&'a Expr<'a>>,

    },
    Try {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        body: &'a [Stmt],
        handlers: &'a [Excepthandler],
        orelse: &'a [Stmt],
        finalbody: &'a [Stmt],

    },
    Assert {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        test: &'a Expr<'a>,
        msg: Option<&'a Expr<'a>>,

    },
    Import {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        names: &'a [Alias],

    },
    ImportFrom {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        module: Option<Ident>,
        names: &'a [Alias],
        level: Option<i32>,

    },
    Global {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        names: &'a [Ident],

    },
    Nonlocal {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        names: &'a [Ident],

    },
    Expr {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        value: &'a Expr<'a>,

    },
    Pass {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
    },
    Break {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
    },
    Continue {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
    },
}
impl<'a> Spanned for Stmt<'a> {
    fn span(&self) -> Span {
        match *self {
            Stmt::FunctionDef { span, .. } |
            Stmt::AsyncFunctionDef { span, .. } |
            Stmt::ClassDef { span, .. } |
            Stmt::Return { span, .. } |
            Stmt::Delete { span, .. } |
            Stmt::Assign { span, .. } |
            Stmt::AugAssign { span, .. } |
            Stmt::AnnAssign { span, .. } |
            Stmt::For { span, .. } |
            Stmt::AsyncFor { span, .. } |
            Stmt::While { span, .. } |
            Stmt::If { span, .. } |
            Stmt::With { span, .. } |
            Stmt::AsyncWith { span, .. } |
            Stmt::Match { span, .. } |
            Stmt::Raise { span, .. } |
            Stmt::Try { span, .. } |
            Stmt::Assert { span, .. } |
            Stmt::Import { span, .. } |
            Stmt::ImportFrom { span, .. } |
            Stmt::Global { span, .. } |
            Stmt::Nonlocal { span, .. } |
            Stmt::Expr { span, .. } |
            Stmt::Pass { span, .. } |
            Stmt::Break { span, .. } |
            Stmt::Continue { span, .. } => span,
        }
    }
}
#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub enum Expr<'a> {
    BoolOp {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        op: Boolop,
        values: &'a [Expr],

    },
    NamedExpr {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        target: &'a Expr<'a>,
        value: &'a Expr<'a>,

    },
    BinOp {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        left: &'a Expr<'a>,
        op: Operator,
        right: &'a Expr<'a>,

    },
    UnaryOp {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        op: Unaryop,
        operand: &'a Expr<'a>,

    },
    Lambda {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        args: &'a Arguments<'a>,
        body: &'a Expr<'a>,

    },
    IfExp {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        test: &'a Expr<'a>,
        body: &'a Expr<'a>,
        orelse: &'a Expr<'a>,

    },
    Dict {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        keys: &'a [Expr],
        values: &'a [Expr],

    },
    Set {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        elts: &'a [Expr],

    },
    ListComp {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        elt: &'a Expr<'a>,
        generators: &'a [Comprehension],

    },
    SetComp {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        elt: &'a Expr<'a>,
        generators: &'a [Comprehension],

    },
    DictComp {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        key: &'a Expr<'a>,
        value: &'a Expr<'a>,
        generators: &'a [Comprehension],

    },
    GeneratorExp {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        elt: &'a Expr<'a>,
        generators: &'a [Comprehension],

    },
    Await {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        value: &'a Expr<'a>,

    },
    Yield {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        value: Option<&'a Expr<'a>>,

    },
    YieldFrom {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        value: &'a Expr<'a>,

    },
    Compare {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        left: &'a Expr<'a>,
        ops: &'a [Cmpop],
        comparators: &'a [Expr],

    },
    Call {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        func: &'a Expr<'a>,
        args: &'a [Expr],
        keywords: &'a [Keyword],

    },
    FormattedValue {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        value: &'a Expr<'a>,
        conversion: Option<i32>,
        format_spec: Option<&'a Expr<'a>>,

    },
    JoinedStr {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        values: &'a [Expr],

    },
    Constant {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        value: Constant,
        kind: Option<String>,

    },
    Attribute {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        value: &'a Expr<'a>,
        attr: Ident,
        ctx: ExprContext,

    },
    Subscript {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        value: &'a Expr<'a>,
        slice: &'a Expr<'a>,
        ctx: ExprContext,

    },
    Starred {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        value: &'a Expr<'a>,
        ctx: ExprContext,

    },
    Name {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        id: Ident,
        ctx: ExprContext,

    },
    List {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        elts: &'a [Expr],
        ctx: ExprContext,

    },
    Tuple {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        elts: &'a [Expr],
        ctx: ExprContext,

    },
    Slice {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        lower: Option<&'a Expr<'a>>,
        upper: Option<&'a Expr<'a>>,
        step: Option<&'a Expr<'a>>,

    },
    MatchAs {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        pattern: &'a Expr<'a>,
        name: Ident,

    },
    MatchOr {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        patterns: &'a [Expr],

    },
}
impl<'a> Spanned for Expr<'a> {
    fn span(&self) -> Span {
        match *self {
            Expr::BoolOp { span, .. } |
            Expr::NamedExpr { span, .. } |
            Expr::BinOp { span, .. } |
            Expr::UnaryOp { span, .. } |
            Expr::Lambda { span, .. } |
            Expr::IfExp { span, .. } |
            Expr::Dict { span, .. } |
            Expr::Set { span, .. } |
            Expr::ListComp { span, .. } |
            Expr::SetComp { span, .. } |
            Expr::DictComp { span, .. } |
            Expr::GeneratorExp { span, .. } |
            Expr::Await { span, .. } |
            Expr::Yield { span, .. } |
            Expr::YieldFrom { span, .. } |
            Expr::Compare { span, .. } |
            Expr::Call { span, .. } |
            Expr::FormattedValue { span, .. } |
            Expr::JoinedStr { span, .. } |
            Expr::Constant { span, .. } |
            Expr::Attribute { span, .. } |
            Expr::Subscript { span, .. } |
            Expr::Starred { span, .. } |
            Expr::Name { span, .. } |
            Expr::List { span, .. } |
            Expr::Tuple { span, .. } |
            Expr::Slice { span, .. } |
            Expr::MatchAs { span, .. } |
            Expr::MatchOr { span, .. } => span,
        }
    }
}
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, Serialize)]
pub enum ExprContext<'a> {
    Load=1,
    Store=2,
    Del=3,
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, Serialize)]
pub enum Boolop<'a> {
    And=1,
    Or=2,
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, Serialize)]
pub enum Operator<'a> {
    Add=1,
    Sub=2,
    Mult=3,
    MatMult=4,
    Div=5,
    Mod=6,
    Pow=7,
    LShift=8,
    RShift=9,
    BitOr=10,
    BitXor=11,
    BitAnd=12,
    FloorDiv=13,
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, Serialize)]
pub enum Unaryop<'a> {
    Invert=1,
    Not=2,
    UAdd=3,
    USub=4,
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, Serialize)]
pub enum Cmpop<'a> {
    Eq=1,
    NotEq=2,
    Lt=3,
    LtE=4,
    Gt=5,
    GtE=6,
    Is=7,
    IsNot=8,
    In=9,
    NotIn=10,
}

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub struct Comprehension<'a> {
    pub target: &'a Expr<'a>,
    pub iter: &'a Expr<'a>,
    pub ifs: &'a [Expr],
    pub is_async: i32,
}

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub enum Excepthandler<'a> {
    ExceptHandler {
        /// The span of the source
        #[derivative(Hash="ignore")]
        #[derivative(PartialEq="ignore")]
        span: Span,
        ast_type: Option<&'a Expr<'a>>,
        name: Option<Ident>,
        body: &'a [Stmt],

    },
}
impl<'a> Spanned for Excepthandler<'a> {
    fn span(&self) -> Span {
        match *self {
            Excepthandler::ExceptHandler { span, .. } => span,
        }
    }
}
#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub struct Arguments<'a> {
    pub posonlyargs: &'a [Arg],
    pub args: &'a [Arg],
    pub vararg: Option<&'a Arg<'a>>,
    pub kwonlyargs: &'a [Arg],
    pub kw_defaults: &'a [Expr],
    pub kwarg: Option<&'a Arg<'a>>,
    pub defaults: &'a [Expr],
}

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub struct Arg<'a> {
    pub arg: Ident,
    pub annotation: Option<&'a Expr<'a>>,
    pub type_comment: Option<String>,
    #[derivative(Hash="ignore")]
    #[derivative(PartialEq="ignore")]
    pub span: Span,
}
impl<'a> Spanned for Arg<'a> {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub struct Keyword<'a> {
    pub arg: Option<Ident>,
    pub value: &'a Expr<'a>,
    #[derivative(Hash="ignore")]
    #[derivative(PartialEq="ignore")]
    pub span: Span,
}
impl<'a> Spanned for Keyword<'a> {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub struct Alias<'a> {
    pub name: Ident,
    pub asname: Option<Ident>,
}

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub struct Withitem<'a> {
    pub context_expr: &'a Expr<'a>,
    pub optional_vars: Option<&'a Expr<'a>>,
}

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub struct MatchCase<'a> {
    pub pattern: &'a Expr<'a>,
    pub guard: Option<&'a Expr<'a>>,
    pub body: &'a [Stmt],
}

#[derive(Derivative, Debug, Clone, Serialize)]
#[derivative(PartialEq, Eq, Hash)]
pub enum TypeIgnore<'a> {
    TypeIgnore {
        lineno: i32,
        tag: String,

    },
}

