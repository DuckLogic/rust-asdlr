#! /usr/bin/env python
"""Generate C code from an ASDL description."""

import os
import sys
import textwrap
import re
import dataclasses

from abc import ABCMeta, abstractmethod
from typing import Union
from argparse import ArgumentParser
from pathlib import Path
from contextlib import contextmanager
from dataclasses import dataclass
from enum import Enum

from .. import asdl

TABSIZE = 4
MAX_COL = 100
AUTOGEN_MESSAGE = "// File automatically generated by {}.\n\n"

BUILTIN_TYPE_MAP = {
    "identifier": "Ident",
    "str": "String",
    "int": "i32",
    "constant": "Constant"
}

class NameStyle(Enum):
    SNAKE_CASE = "snake_case"
    UPPER_SNAKE_CASE = "UPPER_SNAKE_CASE"
    PASCAL_CASE = "PascalCase"

    def convert(self, other: str):
        if '_' in other:
            parts = other.split('_')
        else:
            pending = []
            parts = []
            idx = 0
            length = len(other)
            def flush_pending():
                assert pending
                parts.append(''.join(pending))
                pending.clear()
            while idx < length:
                c = other[idx]
                if c.isupper():
                    if pending and pending[-1].islower():
                        flush_pending()
                    pending.append(c)
                else:
                    pending.append(c)
                idx += 1
            if pending:
                flush_pending()
        return self.convert_parts(parts)

    def convert_parts(self, parts: list[str]) -> str:
        if self == NameStyle.SNAKE_CASE:
            return '_'.join(part.lower() for part in parts)
        elif self == NameStyle.UPPER_SNAKE_CASE:
            return '_'.join(part.upper() for part in parts)
        elif self == NameStyle.PASCAL_CASE:
            return ''.join(part[0].upper() + part[1:].lower() for part in parts)
        else:
            raise AssertionError(repr(self))


def rust_type(name):
    """Return a string for the Rust name of the type.

    This function special cases the default types provided by asdl.
    """
    if name in BUILTIN_TYPE_MAP:
        return BUILTIN_TYPE_MAP[name]
    else:
        return NameStyle.PASCAL_CASE.convert(name)

def reflow_lines(s, depth):
    """Reflow the line s indented depth tabs.

    Return a sequence of lines where no line extends beyond MAX_COL
    when properly indented.  The first line is properly indented based
    exclusively on depth * TABSIZE.  All following lines -- these are
    the reflowed lines generated by this function -- start at the same
    column as the first character beyond the opening { in the first
    line.
    """
    size = MAX_COL - depth * TABSIZE
    if len(s) < size:
        return [s]

    lines = []
    cur = s
    padding = ""
    WHITESPACE_PATTERN = re.compile(r"\s")
    while len(cur) > size:
        i = -1
        for val in WHITESPACE_PATTERN.finditer(s, 0, size):
            i = val.pos
        # XXX this should be fixed for real
        if i == -1 and 'GeneratorExp' in cur:
            i = size + 3
        assert i != -1, "Impossible line %d to reflow: %r" % (size, s)
        lines.append(padding + cur[:i])
        if len(lines) == 1:
            # find new size based on brace
            j = cur.find('{', 0, i)
            if j >= 0:
                j += 2 # account for the brace and the space after it
                size -= j
                padding = " " * j
            else:
                j = cur.find('(', 0, i)
                if j >= 0:
                    j += 1 # account for the paren (no space after it)
                    size -= j
                    padding = " " * j
        cur = cur[i+1:]
    else:
        lines.append(padding + cur)
    return lines

def reflow_rust_string(s, depth):
    return '"%s"' % s.replace('\n', '\\n"\n%s"' % (' ' * depth * TABSIZE))

def is_simple(sum):
    """Return True if a sum is a simple.

    A sum is simple if its types have no fields, e.g.
    unaryop = Invert | Not | UAdd | USub
    """
    for t in sum.types:
        if t.fields:
            return False
    return True

def asdl_of(name, obj):
    if isinstance(obj, asdl.Product) or isinstance(obj, asdl.Constructor):
        fields = ", ".join(map(str, obj.fields))
        if fields:
            fields = "({})".format(fields)
        return "{}{}".format(name, fields)
    else:
        if is_simple(obj):
            types = " | ".join(type.name for type in obj.types)
        else:
            sep = "\n{}| ".format(" " * (len(name) + 1))
            types = sep.join(
                asdl_of(type.name, type) for type in obj.types
            )
        return "{} = {}".format(name, types)

class EmitVisitor(asdl.VisitorBase):
    """Visit that emits lines"""

    def __init__(self, file):
        self.file = file
        self.identifiers = set()
        self.singletons = set()
        self.types = set()
        self.depth = 0
        super(EmitVisitor, self).__init__()

    @contextmanager
    def indent(self, amount: int = 1):
        self.depth += amount
        try:
            yield
        finally:
            self.depth -= amount

    def emit_identifier(self, name):
        self.identifiers.add(str(name))

    def emit_singleton(self, name):
        self.singletons.add(str(name))

    def emit_type(self, name):
        self.types.add(str(name))

    def emit(self, s, reflow=True):
        # XXX reflow long lines?
        if reflow:
            lines = reflow_lines(s, self.depth)
        else:
            lines = [s]
        for line in lines:
            if line:
                line = (" " * TABSIZE * self.depth) + line
            self.file.write(line + "\n")

@dataclass
class SharedAttribute:
    name: str
    rust_type: str
    doc: str = "Shared attribute"

SPAN_ATTRS = {"lineno", "col_offset", "end_lineno", "end_col_offset"}
class RustVisitor(EmitVisitor, metaclass=ABCMeta):
    def rewrite_attributes(self, attrs: list[asdl.Field]) -> list[SharedAttribute]:
        attr_map = {attr.name: attr for attr in attrs}
        res = {}
        if attr_map.keys() >= SPAN_ATTRS:
            assert "span" not in attr_map, attr_map["span"]
            for name in SPAN_ATTRS:
                actual = attr_map[name]
                assert actual.type == "int", \
                    f"Unexpected attr {actual!r}"
                del attr_map[name]
            res["span"] = SharedAttribute(
                name="span",
                rust_type="Span",
                doc="The span of the corresponding source location"
            )
        for val in attr_map.values():
            assert not val.seq and not val.opt, repr(val)
            res[val.name] = SharedAttribute(
                name=val.name,
                rust_type=rust_type(val.type)
            )
        return list(res.values())

    def visitModule(self, mod):
        for dfn in mod.dfns:
            self.visit(dfn)

    def visitType(self, tp):
        self.visit(tp.value, tp.name)

    def visitSum(self, sum, name):
        if is_simple(sum):
            self.simple_sum(sum, name)
        else:
            self.sum_with_constructors(sum, name)

class AbstractVisitorGenerator(RustVisitor, metaclass=ABCMeta):
    @abstractmethod
    def visitModule(self, mod):
        pass

    @abstractmethod
    def arg_type(self, parent: asdl.AST, field: Union[asdl.Field, SharedAttribute]) -> str:
        pass

    @abstractmethod
    def product_return_type(self, item: asdl.Product) -> str:
        pass

    @abstractmethod
    def cons_return_type(self, item: asdl.Constructor) -> str:
        pass

    @abstractmethod
    def enum_return_type(
        self, item: asdl.Sum,
    ) -> str:
        pass

    def simple_sum(self, sum, name):
        # We don't do anything for simple sums
        # Visiting a c-style enum is stupid
        pass 

    def emit_visitor_method(
        self, name: str,
        args: list[str],
        return_type: str
    ):
        if len(args) < 3:
            self.emit(f"fn visit_{name}(&mut self, {', '.join(args)}) -> {return_type};")
        else:
            self.emit(f"fn visit_{name}(")
            with self.indent(2):
                self.emit("&mut self,")
                for arg in args:
                    self.emit(f"{arg},")
            self.emit(f") -> {return_type};")

    def sum_variant_name(self, sum_name, tp: asdl.Constructor):
        tp_name = NameStyle.SNAKE_CASE.convert(tp.name)
        return f"{sum_name}_{tp_name}"

    def sum_with_constructors(self, sum, name):
        def emit(s):
            self.emit(s)
        name = NameStyle.SNAKE_CASE.convert(name)
        args = []
        return_type = self.enum_return_type(sum)
        for tp in sum.types:
            assert isinstance(tp, asdl.Constructor), f"Bad type: {tp!r}"
            for field in self.rewrite_attributes(sum.attributes):
                arg_type = self.arg_type(tp, field)
                args.append(f"{field.name}: {arg_type}")
            for field in tp.fields:
                arg_type = self.arg_type(tp, field)
                args.append(f"{field.name}: {arg_type}")
            self.emit_visitor_method(
                NameStyle.SNAKE_CASE.convert(f"{name}_{tp.name}"),
                args, return_type
            )

    def visitConstructor(self, cons):
        self.emit_visitor_method(
            NameStyle.SNAKE_CASE.convert(cons.name),
            [f"{field.name}: {self.arg_type(cons, field)}"
                for field in cons.fields],
            self.cons_return_type(cons)
        )

    def visitField(self, field):
        raise NotImplementedError

    def visitProduct(self, product, name):
        args = []
        for field in self.rewrite_attributes(product.attributes):
            # rudimentary attribute handling
            arg_type = self.arg_type(product, field)
            self.emit(f"{field.name}: {arg_type}");
        for field in product.fields:
            arg_type = self.arg_type(product, field)
            args.append(f"{field.name}: {arg_type}")
        self.emit_visitor_method(
            NameStyle.SNAKE_CASE.convert(name),
            args,
            self.product_return_type(product)
        )

@dataclass
class AssociatedVisitorType:
    name: str
    bound: str = None
    doc: str = None

    def __str__(self):
        res = [f"Self::{self.name}"]
        if self.bound is not None:
            res.append(f": {self.bound}")
        return ''.join(res)

    def write_decl(self, out: EmitVisitor):
        if self.doc is not None:
            out.emit(f"/// {self.doc}")
        bound_str = F': {self.bound}' if self.bound else ''
        out.emit(f"type {self.name}{bound_str};")

class ClarrifyingVisitor(asdl.VisitorBase):
    def visitModule(self, mod):
        for d in mod.dfns:
            self.visit(d)

    def visitType(self, tp):
        self.visit(tp.value, tp.name)

    def visitSum(self, sum, name):
        sum.name = name
        if is_simple(sum):
            return
        for tp in sum.types:
            assert isinstance(tp, asdl.Constructor)
            # Give access to parent
            setattr(tp, 'parent_sum', sum)
            self.visit(tp, tp.name)

    def visitProduct(self, product, name):
        product.name = name

    def visitConstructor(self, cons, name):
        cons.name = name

class GenericVisitorGenerator(AbstractVisitorGenerator):
    """Generate a generic visitor,
    completely generic over result types (via associated types).

    This is how we avoid constructing an AST."""
    pending_associated_types: dict[str, AssociatedVisitorType]
    def __init__(self, file):
        super().__init__(file)
        self.pending_associated_types = dict()

    def visitModule(self, mod):
        self.emit("pub trait ASTVisitor {")
        with self.indent():
            for dfn in mod.dfns:
                self.visit(dfn)
            self.emit("")
            for associated in self.pending_associated_types.values():
                associated.write_decl(self)
            self.pending_associated_types.clear()
        self.emit("}")

    def arg_type(self, parent: asdl.AST, field: Union[asdl.Field, SharedAttribute]) -> str:
        if isinstance(field, SharedAttribute):
            return field.rust_type
        field_type = field.type
        if field_type in BUILTIN_TYPE_MAP:
            return BUILTIN_TYPE_MAP[field.type]
        else:
            return f"Self::{rust_type(field.type)}"

    def product_assoc_type(self, item: asdl.Product) -> AssociatedVisitorType:
        return AssociatedVisitorType(
            name=rust_type(item.name),
        )

    def cons_assoc_type(self, item: asdl.Constructor) -> str:
        return AssociatedVisitorType(
            name=rust_type(item.name),
        )

    def enum_assoc_type(
        self, parent: asdl.Sum,
    ) -> AssociatedVisitorType:
        base_name = rust_type(parent.name)
        return AssociatedVisitorType(
            name=base_name,
            doc=f"The enum {base_name}"
        )

    def return_type(self, assoc: AssociatedVisitorType) -> str:
        assert assoc.name not in self.pending_associated_types
        self.pending_associated_types[assoc.name] = assoc
        return assoc.name

    def product_return_type(self, item: asdl.Product) -> str:
        return self.return_type(self.product_assoc_type(item))

    def cons_return_type(self, item: asdl.Constructor) -> str:
        return self.return_type(self.cons_assoc_type(item))

    def enum_return_type(
        self, item: asdl.Sum,
    ) -> str:
        return self.return_type(self.enum_assoc_type(
            item
        ))



class RustTypeDeclareVisitor(RustVisitor):
    def __init__(self, *args):
        super().__init__(*args)
        self.inside_enum = False

    @contextmanager
    def switch_inside_enum(self, /, new_val: bool):
        old_val = self.inside_enum
        self.inside_enum = new_val
        yield
        self.inside_enum = old_val

    def visitModule(self, mod):
        for dfn in mod.dfns:
            self.visit(dfn)

    def visitType(self, tp):
        self.visit(tp.value, tp.name)

    def visitSum(self, sum, name):
        if is_simple(sum):
            self.simple_sum(sum, name)
        else:
            self.sum_with_constructors(sum, name)

    def simple_sum(self, sum, name):
        enum = []
        for i, tp in enumerate(sum.types):
            enum.append(f"{tp.name}={i + 1},")
        type_name = rust_type(name)
        self.emit(f"enum {type_name} {{")
        with self.indent():
            for line in enum:
                self.emit(line)
        self.emit("}")
        self.emit("")

    def sum_with_constructors(self, sum, name):
        def emit(s):
            self.emit(s)
        emit(f"pub enum {rust_type(name)} {{")
        with self.indent():
            for idx, tp in enumerate(sum.types):
                emit(f"{tp.name} {{")
                with self.indent():
                    for field in self.rewrite_attributes(sum.attributes):
                        # rudimentary attribute handling
                        attr_type = field.rust_type
                        if field.doc is not None:
                            emit(f"/// {field.doc}")
                        emit(f"{field.name}: {attr_type},")
                    with self.switch_inside_enum(True):
                        self.visit(tp)
                emit("},")
        emit("}")
        def emit_match(field):
            emit("match *self {")
            for idx, tp in enumerate(sum.types):
                with self.indent():
                    last = f"=> {field.name}," if idx == len(sum.types) - 1 else "|"
                    emit(f"{rust_type(name)}::{tp.name} {{ ref {field.name}, .. }} {last}")
            emit("}")
        self.emit_rewritten_attrs(
            sum.attributes,
            name=name,
            handler=emit_match
        )

    def emit_rewritten_attrs(self, attrs, *, name, handler):
        def emit(*args):
            self.emit(*args)
        def emit_handler(field: SharedAttribute):
            attr_type = str(field.rust_type)
            if field.doc is not None:
                emit(f"/// {field.doc}")
            emit(f"fn {field.name}(&self) -> &{rust_type(attr_type)} {{")
            with self.indent():
                handler(field)
            emit("}")
        if attrs:
            rewritten_attrs=self.rewrite_attributes(attrs)
            span_field=None
            for field in list(rewritten_attrs):
                if field.name == "span" and field.rust_type == "Span":
                    span_field=field
                    rewritten_attrs.remove(field)
            if rewritten_attrs:
                emit(f"impl {rust_type(name)} {{")
                with self.indent():
                    for field in rewritten_attrs:
                        emit_handler(field)
                emit("}")
            if span_field is not None:
                emit(f"impl Spanned for {rust_type(name)} {{")
                with self.indent():
                    emit_handler(dataclasses.replace(
                        span_field, doc=None
                    ))
                emit("}")


    def visitConstructor(self, cons):
        if cons.fields:
            amount = 0
            if not self.inside_enum:
                amount = 1
                self.emit(f"pub struct {cons.name} {{")
            with self.indent(amount):
                for f in cons.fields:
                    self.visit(f)
            if not self.inside_enum:
                self.emit("}")
            self.emit("")

    def visitField(self, field):
        # XXX need to lookup field.type, because it might be something
        # like a builtin...
        type_name = rust_type(field.type)
        name = field.name
        if field.seq:
            self.emit(f"{name}: Vec<{type_name}>,")
        else:
            self.emit(f"{name}: {type_name},")

    def visitProduct(self, product, name):
        self.emit(f"pub struct {rust_type(name)} {{")
        with self.indent():
            for f in product.fields:
                self.visit(f)
            for field in self.rewrite_attributes(product.attributes):
                # rudimentary attribute handling
                self.emit(f"{field.name}: {field.rust_type},");
        self.emit("}")
        def emit_field_access(field):
            self.emit(f"&self.{field.name}")
        self.emit_rewritten_attrs(
            product.attributes,
            name=name,
            handler=emit_field_access
        )
        self.emit("")

def ast_func_name(name):
    return f"_PyAST_{name}"



class ChainOfVisitors:
    def __init__(self, *visitors):
        self.visitors = visitors

    def visit(self, obj):
        for v in self.visitors:
            v.visit(obj)
            if isinstance(v, EmitVisitor):
                v.emit("")


def generate_ast_state(module_state, f):
    f.write('struct AstState {\n')
    f.write('    initialized: bool;\n')
    for s in module_state:
        f.write(f'    {s}: PyObject,\n')
    f.write('}')


def generate_module_def(mod, f):
    # Gather all the data needed for ModuleSpec
    visitor_list = set()
    with open(os.devnull, "w") as devnull:
        pass

    state_strings = {
        "ast",
        "_fields",
        "__match_args__",
        "__doc__",
        "__dict__",
        "__module__",
        "_attributes",
    }
    module_state = state_strings.copy()
    for visitor in visitor_list:
        for identifier in visitor.identifiers:
            module_state.add(identifier)
            state_strings.add(identifier)
        for singleton in visitor.singletons:
            module_state.add(singleton)
        for tp in visitor.types:
            module_state.add(tp)
    state_strings = sorted(state_strings)
    module_state = sorted(module_state)

    print(textwrap.dedent("""

    """).strip(), file=f)

    generate_ast_state(module_state, f)


def write_source(mod, f):
    generate_module_def(mod, f)

    v = ChainOfVisitors(
        RustTypeDeclareVisitor(f),
        ClarrifyingVisitor(),
        GenericVisitorGenerator(f)
    )
    v.visit(mod)

def main(input_filename, rust_filename, dump_module=False):
    auto_gen_msg = AUTOGEN_MESSAGE.format("/".join(Path(__file__).parts[-2:]))
    mod = asdl.parse(input_filename)
    if dump_module:
        print('Parsed Module:')
        print(mod)
    if not asdl.check(mod):
        sys.exit(1)

    with rust_filename.open("w") as rust_file:
        rust_file.write(auto_gen_msg)

        write_source(mod, rust_file)

    print(f"{rust_filename}, regenerated.")

if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument("input_file", type=Path)
    parser.add_argument("-R", "--rust-file", type=Path, required=True)
    parser.add_argument("-d", "--dump-module", action="store_true")

    args = parser.parse_args()
    main(args.input_file, args.rust_file, args.dump_module)
